/**
 * A D programming language implementation of the
 * General Decimal Arithmetic Specification,
 * Version 1.70, (25 March 2009).
 *
 * by Paul D. Anderson
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
**/

// TODO: ensure context flags are being set and cleared properly.

// TODO: opEquals unit test should include numerically equal testing.

// TODO: write some test cases for flag setting. test the add/sub/mul/div functions

// TODO: to/from real or double (float) values needs definition and implementation.

// TODO: define values for payloads.

module decimal.arithmetic;

import decimal.context;
import decimal.digits;
import decimal.decimal;
import std.array: insertInPlace;
import std.bigint;
import std.conv;
import std.ctype: isdigit;
import std.stdio: write, writeln;
import std.string;

// BigInt BIG_ONE = BigInt(1);
// TODO: BIG_ONE, BIG_ZERO

//--------------------------------
// conversion to/from strings
//--------------------------------

// UNREADY: toSciString. Description. Unit Tests.
/**
 * Converts a Decimal to a string representation.
 */
public string toSciString(const Decimal num) {

	// string representation of special values
	if (num.sval > Decimal.SV.ZERO) {
		string str;
		switch(num.sval) {
			case Decimal.SV.ZERO:
				str = "0";
				break;
			case Decimal.SV.INF:
				str = "Infinity";
				break;
			case Decimal.SV.SNAN:
				str = "sNaN";
				break;
			default:
				str = "NaN";
		}
		if (num.sval >= Decimal.SV.QNAN && num.mant != BigInt(0)) {
			str ~= toDecString(num.mant);
		}
		return num.sign ? "-" ~ str : str;
	}

	// string representation of finite numbers
	string temp = toDecString(num.mant);
	char[] cstr = temp.dup;
	int clen = cstr.length;
	int adjx = num.expo + clen - 1;

	// if exponent is small, don't use exponential notation
	if (num.expo <= 0 && adjx >= -6) {
		// if exponent is not zero, insert a decimal point
		if (num.expo != 0) {
			int point = std.math.abs(num.expo);
			// if coefficient is too small, pad with zeroes
			if (point > clen) {
				cstr = zfill(cstr, point);
				clen = cstr.length;
			}
			// if no chars precede the decimal point, prefix a zero
			if (point == clen) {
				cstr = "0." ~ cstr;
			}
			// otherwise insert a decimal point
			else {
				insertInPlace(cstr, cstr.length - point, ".");
			}
		}
		return num.sign ? ("-" ~ cstr).idup : cstr.idup;
	}
	// use exponential notation
	if (clen > 1) {
		insertInPlace(cstr, 1, ".");
	}
	string xstr = to!string(adjx);
	if (adjx >= 0) {
		xstr = "+" ~ xstr;
	}
	string str = (cstr ~ "E" ~ xstr).idup;
	if (num.sign) {
		return "-" ~ str;
	}
	else {
		return str;
	}

};	// end toString()

// UNREADY: toEngString. Not implemented: returns toSciString
/**
 * Converts a Decimal to an engineering string representation.
 */
public string toEngString(const Decimal num) {
	// TODO: implement this.
	return toSciString(num);
};

// UNREADY: toNumber. Description. Corner Cases.
/**
 * Converts a string into a Decimal.
 */
public Decimal toNumber(const string numeric_string) {
	Decimal num;
	num.clear;
	num.sign = false;

	// strip, copy, tolower
	char[] str = strip(numeric_string).dup;
	tolowerInPlace(str);

	// get sign, if any
	if (startsWith(str,"-")) {
		num.sign = true;
		str = str[1..$];
	}
	else if (startsWith(str,"+")) {
		str = str[1..$];
	}

	// check for NaN
	if (startsWith(str,"nan")) {
		num.sval = Decimal.SV.QNAN;
		if (str == "nan") {
			num.mant = BigInt(0);
//			writeln("return 1");
			return num;
		}
		// set payload
		str = str[3..$];
		// ensure string is all digits
		foreach(char c; str) {
			if (!isdigit(c)) {
//				writeln("return 2");
				return num;
			}
		}
		// convert string to payload
		num.mant = BigInt(str.idup);
//		writeln("return 3");
		return num;
	};

	// check for sNaN
	if (startsWith(str,"snan")) {
		num.sval = Decimal.SV.SNAN;
		if (str == "snan") {
			num.mant = BigInt(0);
//			writeln("return 4");
			return num;
		}
		// set payload
		str = str[4..$];
		// ensure string is all digits
		foreach(char c; str) {
			if (!isdigit(c)) {
//				writeln("return 5");
				return num;
			}
		}
		// convert string to payload
		num.mant = BigInt(str.idup);
//		writeln("return 6");
		return num;
	};

	// check for infinity
	if (str == "inf" || str == "infinity") {
		num.sval = Decimal.SV.INF;
//		writeln("return 7");
		return num;
	};

	// up to this point, num has been qNaN
	num.clear();
	// check for exponent
	int pos = indexOf(str, 'e');
	if (pos > 0) {
		// if it's just a trailing 'e', return NaN
		if (pos == str.length - 1) {
			num.sval = Decimal.SV.QNAN;
//			writeln("return 8");
			return num;
		}
		// split the string into coefficient and exponent
		char[] xstr = str[pos+1..$];
		str = str[0..pos];
		// assume exponent is positive
		bool xneg = false;
		// check for minus sign
		if (startsWith(xstr, "-")) {
			xneg = true;
			xstr = xstr[1..$];
		}
		// check for plus sign
		else if (startsWith(xstr, "+")) {
			xstr = xstr[1..$];
		}

		// ensure it's not now empty
		if (xstr.length < 1) {
			num.sval = Decimal.SV.QNAN;
//			writeln("return 9");
			return num;
		}

		// ensure exponent is all digits
		foreach(char c; xstr) {
			if (!isdigit(c)) {
				num.sval = Decimal.SV.QNAN;
//				writeln("return 10");
		return num;
			}
		}

		// trim leading zeros
		while (xstr[0] == '0' && xstr.length > 1) {
			xstr = xstr[1..$];
		}

		// make sure it will fit into an int
		if (xstr.length > 10) {
			num.sval = Decimal.SV.QNAN;
//			writeln("return 11");
			return num;
		}
		if (xstr.length == 10) {
			// try to convert it to a long (should work) and
			// then see if the long value is too big (or small)
			long lex = to!long(xstr);
			if ((xneg && (-lex < int.min)) || lex > int.max) {
				num.sval = Decimal.SV.QNAN;
//				writeln("return 12");
		return num;
			}
			num.expo = cast(int) lex;
		}
		else {
			// everything should be copacetic at this point
			num.expo = to!int(xstr);
		}
		if (xneg) {
			num.expo = -num.expo;
		}
	}
	else {
		num.expo = 0;
	}

	// remove trailing decimal point
	if (endsWith(str, ".")) {
		str = str[0..$-1];
	}
	// strip leading zeros
	while (str[0] == '0' && str.length > 1) {
		str = str[1..$];
	}

	// remove internal decimal point
	int point = indexOf(str, '.');
	if (point >= 0) {
		// excise the point and adjust exponent
		str = str[0..point] ~ str[point+1..$];
		int diff = str.length - point;
		num.expo -= diff;
	}

	// ensure string is not empty
	if (str.length < 1) {
		num.sval = Decimal.SV.QNAN;
//		writeln("return 13");
		return num;
	}

	// ensure string is all digits
	foreach(char c; str) {
		if (!isdigit(c)) {
			num.sval = Decimal.SV.QNAN;
//			writeln("return 14");
			return num;
		}
	}
	// convert string to BigInt
	num.mant = BigInt(str.idup);
	num.digits = numDigits(num.mant);
	if (num.mant == BigInt(0)) {
		 num.sval = Decimal.SV.ZERO;
	}

//	writeln("return 15");
	return num;
}

//--------------------------------
// classification functions
//--------------------------------

// READY: radix
/**
 * Returns the radix of this representation (10).
 */
public int radix() {
	return 10;
}

// READY: classify
/**
 * Returns a string indicating the class and sign of the number.
 * Classes are: sNaN, NaN, Infinity, Subnormal, Zero, Normal.
 */
public string classify(const Decimal num) {
	if (num.isSignaling()) {
		return "sNaN";
	}
	if (num.isQuiet) {
		return "NaN";
	}
	if (num.isInfinite) {
		return num.sign ? "-Infinity" : "+Infinity";
	}
	if (num.isSubnormal) {
		return num.sign ? "-Subnormal" : "+Subnormal";
	}
	if (num.isZero) {
		return num.sign ? "-Zero" : "+Zero";
	}
	return num.sign ? "-Normal" : "+Normal";
}

//--------------------------------
// copy functions
//--------------------------------

// READY: copy
/**
 * Returns a copy of the operand.
 * The copy is unaffected by context; no flags are changed.
 */
public Decimal copy(const Decimal num) {
	return num.dup;
}

// READY: copyAbs
/**
 * Returns a copy of the operand with a positive sign.
 * The copy is unaffected by context; no flags are changed.
 */
public Decimal copyAbs(const Decimal num) {
	Decimal copy = num.dup;
	copy.sign = false;
	return copy;
}

// READY: copyNegate
/**
 * Returns a copy of the operand with the sign inverted.
 * The copy is unaffected by context; no flags are changed.
 */
public Decimal copyNegate(const Decimal num) {
	Decimal copy = num.dup;
	copy.sign = !num.sign;
	return copy;
}

// READY: copySign
/**
 * Returns a copy of the first operand with the sign of the second operand.
 * The copy is unaffected by context; no flags are changed.
 */
public Decimal copySign(const Decimal op1, const Decimal op2) {
	Decimal copy = op1.dup;
	copy.sign = op2.sign;
	return copy;
}

// UNREADY: quantize. Description. Logic.
/**
 * Returns the number which is equal in value and sign
 * to the first operand and which has its exponent set
 * to be equal to the exponent of the second operand.
 */
public Decimal quantize(const Decimal op1, const Decimal op2) {
	Decimal result;
	if (isInvalidBinaryOp(op1, op2, result)) {
		return result;
	}
	if (op1.isInfinite != op2.isInfinite() ||
		op2.isInfinite != op1.isInfinite()) {
		return flagInvalid();
	}
	if (op1.isInfinite() && op2.isInfinite()) {
		return op1.dup;
	}
	result = op1;
	int diff = op1.expo - op2.expo;
	if (diff == 0) {
		return result;
	}
	// need to add a check where the result is zero and op1 is negative --
	// then the result is -zero.
	if (diff > 0) {
		decShl(result.mant, diff);
		result.digits += diff;
		result.expo = op2.expo;
		if (result.digits > context.precision) {
			result = Decimal.NaN;
		}
		return result;
	}
	else {
		pushPrecision;
    	context.precision = (-diff > op1.digits) ? 0 : op1.digits + diff;
		round(result);
		result.expo = op2.expo;
		popPrecision;
		return result;
	}
}

//--------------------------------
// absolute value, unary plus and minus functions
//--------------------------------

// UNREADY: reduce. Description. Flags.
/**
 * Reduces operand to simplest form. Trailing zeros are removed.
 */
public Decimal reduce(const Decimal num) {
	Decimal result;
	if (invalidOperand(num, result)) {
		return result;
	}
	result = num;
	if (!result.isFinite()) {
		return result;
	}

	// TODO: is there a more efficient way to do this?
	// Is checking the coefficient for trailing zeros easier to compute?
	BigInt temp = result.mant % 10;
	while (result.mant != 0 && temp == 0) {
		result.expo++;
		result.mant = result.mant / 10;
		temp = result.mant % 10;
	}
	if (result.mant == 0) {
		result.sval = Decimal.SV.ZERO;
		result.expo = 0;
	}
	result.digits = numDigits(result.mant);
	return result;
}

// READY: abs
/**
 *	Absolute value -- returns a copy and clears the negative sign, if needed.
 *	This operation rounds the number and may set flags.
 *	Result is equivalent to plus(num) for positive numbers
 *	and to minus(num) for negative numbers.
 *	To return the absolute value without rounding or setting flags
 *	use the "copyAbs" function.
 */
/// Returns a new Decimal equal to the absolute value of this Decimal.
public Decimal abs(const Decimal num) {
	Decimal result;
	if(invalidOperand(num, result)) {
		return result;
	}
	result = copyAbs(num);
	round(result);
	return result;
}

// READY: plus
/**
 *	Unary plus -- returns a copy with same sign as the number.
 *	Does NOT return a positive copy of a negative number!
 *	This operation rounds the number and may set flags.
 *	Result is equivalent to add('0', number).
 *	To copy without rounding or setting flags use the "copy" function.
 */
public Decimal plus(const Decimal num) {
	Decimal result;
	if(invalidOperand(num, result)) {
		return result;
	}
	result = num;
	round(result);
	return result;
}

// READY: minus
/**
 *	Unary minus -- returns a copy with the opposite sign.
 *	This operation rounds the number and may set flags.
 *	Result is equivalent to subtract('0', number).
 *	To copy without rounding or setting flags use the "copyNegate" function.
 */
public Decimal minus(const Decimal num) {
	Decimal result;
	if(invalidOperand(num, result)) {
		return result;
	}
	result = copyNegate(num);
	round(result);
	return result;
}

//-----------------------------------
// next-plus, next-minus, next-toward
//-----------------------------------

// UNREADY: nextPlus. Description. Unit Tests.
public Decimal nextPlus(const Decimal num) {
	Decimal result;
	if (invalidOperand(num, result)) {
		return result;
	}
	if (num.isInfinite) {
		if (num.sign) {
			return copyNegate(Decimal.max);
		}
		else {
			return num.dup;
		}
	}
	int adjx = num.expo + num.digits - context.precision;
	if (adjx < context.eTiny) {
			return Decimal(0L, context.eTiny);
	}
	Decimal addend = Decimal(1, adjx);
	result = add(num, addend, true); // really? does this guarantee no flags?
	if (result > Decimal.max) {
		result = Decimal.POS_INF;
	}
	return result;
}

// UNREADY: nextMinus. Description. Unit Tests.
public Decimal nextMinus(const Decimal num) {
	Decimal result;
	if (invalidOperand(num, result)) {
		return result;
	}
	if (num.isInfinite) {
		if (!num.sign) {
			return Decimal.max;
		}
		else {
			return num.dup;
		}
	}
	// This is necessary to catch the special case where mant == 1
	Decimal red = reduce(num);
	int adjx = red.expo + red.digits - context.precision;
	if (num.mant == 1) adjx--;
	if (adjx < context.eTiny) {
		return Decimal(0L, context.eTiny);
	}
	Decimal addend = Decimal(1, adjx);
	result = num - addend; //subtract(num, addend, true); // really? does this guarantee no flags?
	if (result < copyNegate(Decimal.max)) {
		result = Decimal.NEG_INF;
	}
	return result;
}

// UNREADY: nextToward. Description. Unit Tests.
public Decimal nextToward(const Decimal op1, const Decimal op2) {
	Decimal result;
	if (isInvalidBinaryOp(op1, op2, result)) {
		return result;
	}
	int comp = compare(op1, op2);
	if (comp < 0) return nextPlus(op1);
	if (comp > 0) return nextMinus(op1);
	result = copySign(op1, op2);
	round(result);
	return result;
}

//--------------------------------
// comparison functions
//--------------------------------

// READY: sameQuantum
/**
 * Returns true if the numbers have the same exponent.
 * No context flags are set.
 * If either operand is NaN or Infinity, returns true if and only if
 * both operands are NaN or Infinity, respectively.
 */
public bool sameQuantum(const Decimal op1, const Decimal op2) {
	if (op1.isNaN || op2.isNaN) {
		return op1.isNaN && op2.isNaN;
	}
	if (op1.isInfinite || op2.isInfinite) {
		return op1.isInfinite && op2.isInfinite;
	}
	return op1.expo == op2.expo;
}

// UNREADY: compare
public int compare(const Decimal op1, const Decimal op2, bool rounded = true) {

	// any operation with a signaling NaN is invalid.
	// if both are signaling, return as if op1 > op2.
	if (op1.isSignaling || op2.isSignaling) {
		context.setFlag(INVALID_OPERATION);
		return op1.isSignaling ? 1 : -1;
	}

	// NaN returns > any number, including NaN
	// if both are NaN, return as if op1 > op2.
	if (op1.isNaN || op2.isNaN) {
		return op1.isNaN ? 1 : -1;
	}

	// if signs differ, just compare the signs
	if (op1.sign != op2.sign) {
		// check for zeros: +0 and -0 are equal
		if (op1.isZero && op2.isZero) {
			return 0;
		}
		return op1.sign ? -1 : 1;
	}

	// otherwise, compare the numbers numerically
	int diff = (op1.expo + op1.digits) - (op2.expo + op2.digits);
	if (!op1.sign) {
		if (diff > 0) return 1;
		if (diff < 0) return -1;
	}
	else {
		if (diff > 0) return -1;
		if (diff < 0) return 1;
	}

	// when all else fails, subtract
	Decimal result = subtract(op1, op2, rounded);

	// test the coefficient
	// result.isZero may not be true if the result isn't rounded
	if (result.mant == 0) return 0;
	return result.sign ? -1 : 1;
}

// UNREADY: equals. Verify 'equals' is identical to 'compare == 0'.
/**
 * Returns true if this Decimal is equal to the specified Decimal.
 * A NaN is not equal to any number, not even to another NaN.
 * Infinities are equal if they have the same sign.
 * Zeros are equal regardless of sign.
 * Finite numbers are equal if they are numerically equal to the current precision.
 * A Decimal is not equal to itself (this != this) if it is a NaN.
 */
public bool equals(
	const Decimal op1, const Decimal op2, const bool rounded = true) {

	// any operation with a signaling NaN is invalid.
	// NaN is never equal to anything, not even another NaN
	if (op1.isSignaling || op2.isSignaling) {
		context.setFlag(INVALID_OPERATION);
		return false;
	}

	// if either is NaN...
	if (op1.isNaN || op2.isNaN) return false;

	// if either is infinite...
	if (op1.isInfinite || op2.isInfinite) {
		return (op1.sval == op2.sval && op1.sign == op2.sign);
	}

	// if either is zero...
	if (op1.isZero || op2.isZero) {
		return (op1.isZero && op2.isZero);
	}

	// if their signs differ
	if (op1.sign != op2.sign) {
		return false;
	}

	// compare the numbers numerically
	int diff = (op1.expo + op1.digits) - (op2.expo + op2.digits);
	if (diff != 0) {
		return false;
	}

	// if they have the same representation, they are equal
	if (op1.expo == op2.expo && op1.mant == op2.mant) {
		return true;
	}

	// otherwise they are equal if they represent the same value
	Decimal result = subtract(op1, op2, rounded);
	return result.mant == 0;
}

// UNREADY: compareSignal. Unit Tests.
/**
 * Compares the numeric values of two numbers. CompareSignal is identical to
 * compare except that quiet NaNs are treated as if they were signaling.
 */
public int compareSignal(const Decimal op1, const Decimal op2,
		bool rounded = true) {

	// any operation with NaN is invalid.
	// if both are NaN, return as if op1 > op2.
	if (op1.isNaN || op2.isNaN) {
		context.setFlag(INVALID_OPERATION);
		return op1.isNaN ? 1 : -1;
	}
	return (compare(op1, op2, rounded));
}

// UNREADY: compareTotal
/// Returns 0 if the numbers are equal and have the same representation
public int compareTotal(const Decimal op1, const Decimal op2) {
	if (op1.sign != op2.sign) {
		return op1.sign ? -1 : 1;
	}
	if (op1.isQuiet || op2.isQuiet) {
		if (op1.isQuiet && op2.isQuiet) {
			return 0;
		}
		return op1.isQuiet ? 1 : -1;
	}
	if (op1.isSignaling || op2.isSignaling) {
		return 0;
	}
	if (op1.isInfinite || op2.isInfinite) {
		return 0;
	}
	int diff = (op1.expo + op1.digits) - (op2.expo + op2.digits);
	if (diff > 0) return 1;
	if (diff < 0) return -1;
	Decimal result = op1 - op2;
	if (result.isZero) {
		if (op1.expo > op2.expo) return 1;
		if (op1.expo < op2.expo) return -1;
		return 0;
	}
	return result.sign ? -1 : 1;
}

// UNREADY: compareTotalMagnitude
int compareTotalMagnitude(const Decimal op1, const Decimal op2) {
	return compareTotal(copyAbs(op1), copyAbs(op2));
}

// UNREADY: max. Flags.
// TODO: this is where the need for flags comes in.
/**
 * Returns the maximum of the two operands (or NaN).
 * If either is a signaling NaN, or both are quiet NaNs, a NaN is returned.
 * Otherwise, Any (finite or infinite) number is larger than a NaN.
 * If they are not numerically equal, the larger is returned.
 * If they are numerically equal:
 * 1) If the signs differ, the one with the positive sign is returned.
 * 2) If they are positive, the one with the larger exponent is returned.
 * 3) If they are negative, the one with the smaller exponent is returned.
 * 4) Otherwise, they are indistinguishable; the first is returned.
 */
const(Decimal) max(const Decimal op1, const Decimal op2) {
	// if both are NaNs or either is an sNan, return NaN.
	if (op1.isNaN && op2.isNaN || op1.isSignaling || op2.isSignaling) {
		return Decimal.NaN;
	}
	// if one op is a quiet NaN return the other
	if (op1.isQuiet || op2.isQuiet) {
		return (op1.isQuiet) ? op2 : op1;
	}
	// if the signs differ, return the unsigned operand
	if (op1.sign != op2.sign) {
		return op1.sign ? op2 : op1;
	}
	// if not numerically equal, return the larger
	int comp = compare(op1, op2);
	if (comp != 0) {
		return comp > 0 ? op1 : op2;
	}
	// if they have the same exponent they are identical, return either
	if (op1.expo == op2.expo) {
		return op1;
	}
	// if they are non-negative, return the one with larger exponent.
	if (op1.sign == 0) {
		return op1.expo > op2.expo ? op1 : op2;
	}
	// else they are negative; return the one with smaller exponent.
	return op1.expo > op2.expo ? op2 : op1;
}

// UNREADY: maxMagnitude. Flags.
const(Decimal) maxMagnitude(const Decimal op1, const Decimal op2) {
	return max(copyAbs(op1), copyAbs(op2));
}

// UNREADY: min. Flags.
/**
 * Returns the minimum of the two operands (or NaN).
 * If either is a signaling NaN, or both are quiet NaNs, a NaN is returned.
 * Otherwise, Any (finite or infinite) number is smaller than a NaN.
 * If they are not numerically equal, the smaller is returned.
 * If they are numerically equal:
 * 1) If the signs differ, the one with the negative sign is returned.
 * 2) If they are negative, the one with the larger exponent is returned.
 * 3) If they are positive, the one with the smaller exponent is returned.
 * 4) Otherwise, they are indistinguishable; the first is returned.
 */
const(Decimal) min(const Decimal op1, const Decimal op2) {
	// if both are NaNs or either is an sNan, return NaN.
	if (op1.isNaN && op2.isNaN || op1.isSignaling || op2.isSignaling) {
/*		Decimal result;
		result.flags = INVALID_OPERATION;*/
		return Decimal.NaN;
	}
	// if one op is a quiet NaN return the other
	if (op1.isQuiet || op2.isQuiet) {
		return (op1.isQuiet) ? op2 : op1;
	}
	// if the signs differ, return the unsigned operand
	if (op1.sign != op2.sign) {
		return op1.sign ? op1 : op2;
	}
	// if not numerically equal, return the smaller
	int comp = compare(op1, op2);
	if (comp != 0) {
		return comp < 0 ? op1 : op2;
	}
	// if they have the same exponent they are identical, return either
	if (op1.expo == op2.expo) {
		return op1;
	}
	// if they are non-negative, return the one with smaller exponent.
	if (op1.sign == 0) {
		return op1.expo < op2.expo ? op1 : op2;
	}
	// else they are negative; return the one with larger exponent.
	return op1.expo < op2.expo ? op2 : op1;
}

// UNREADY: minMagnitude. Flags.
const(Decimal) minMagnitude(const Decimal op1, const Decimal op2) {
	return min(copyAbs(op1), copyAbs(op2));
}

//------------------------------------------
// binary arithmetic operations
//------------------------------------------

/**
 * Shifts the first operand by the specified number of decimal digits.
 * (Not binary digits!) Positive values of the second operand shift the
 * first operand left (multiplying by tens). Negative values shift right
 * (divide by 10s). If the number is NaN, or if the shift value is less
 * than -precision or greater than precision, an INVALID_OPERATION is signaled.
 * An infinite number is returned unchanged.
 */
public Decimal shift(const Decimal op1, const int op2) {

	Decimal result;
	// check for NaN operand
	if (invalidOperand(op1, result)) {
		return result;
	}
	if (op2 < -context.precision || op2 > context.precision) {
		result = flagInvalid();
		return result;
	}
	if (op1.isInfinite) {
		return op1.dup;
	}
	if (op2 == 0) {
		return op1.dup;
	}
	result = op1.dup;
	if (op2 > 0) {
		decShl(result.mant, op2);
	}
	else {
		decShr(result.mant, -op2);
	}
	result.expo -= op2;
	result.digits += op2;

	return result;
}

// READY: add
/**
 * Adds two numbers.
 *
 * This function corresponds to the "add and subtract" function
 * in the General Decimal Arithmetic Specification and is the basis
 * for the opAdd and opSub functions for the Decimal struct.
 */
public Decimal add(const Decimal op1, const Decimal op2, bool rounded = true) {
	Decimal augend = op1.dup;
	Decimal addend = op2.dup;
	Decimal sum;	// sum is initialized to quiet NaN
	// check for NaN operand(s)
	if (isInvalidBinaryOp(augend, addend, sum)) {
		return sum;
	}
	// if both operands are infinite
	if (augend.isInfinite && addend.isInfinite) {
		// (+inf) + (-inf) => invalid operation
		if (augend.sign != addend.sign) {
			return flagInvalid();
		}
		// both infinite with same sign
		return augend;
	}

	if (isInvalidAddition(augend, addend, sum)) {
		return sum;
	}
	// only augend is infinite,
	if (augend.isInfinite) {
		return augend;
	}
	// only addend is infinite
	if (addend.isInfinite) {
		return addend;
	}

	// add(0, 0)
	if (augend.isZero && addend.isZero) {
		sum = augend;
		sum.sign = augend.sign && addend.sign;
		return sum;
	}

	// TODO: this can never return zero, right?
	// align the operands
	alignOps(augend, addend);

	// at this point, the result will be finite and not zero
	// (before rounding)
	sum.clear();

	// if operands have the same sign...
	if (augend.sign == addend.sign) {
		sum.mant = augend.mant + addend.mant;
		sum.sign = augend.sign;
	}
	// ...else operands have different signs
	else {
		sum.mant = augend.mant - addend.mant;
		sum.sign = augend.sign;
		if (sum.mant < BigInt(0)) {
			sum.mant = -sum.mant;
			sum.sign = !sum.sign;
		}
	}
	// set the number of digits and the exponent
	sum.digits = numDigits(sum.mant);
	sum.expo = augend.expo;

	// round the result
	if (rounded) {
		round(sum);
	}
	return sum;
}	// end add(augend, addend)

// READY: subtract
/**
 * Subtracts a number from another number.
 *
 * This function corresponds to the "add and subtract" function
 * in the General Decimal Arithmetic Specification and is the basis
 * for the opAdd and opSub functions for the Decimal struct.
 */
public Decimal subtract(const Decimal minuend, const Decimal subtrahend,
		const bool rounded = true) {
	return add(minuend, copyNegate(subtrahend), rounded);
}	// end subtract(minuend, subtrahend)

// READY: multiply
/**
 * Multiplies two numbers.
 *
 * This function corresponds to the "multiply" function
 * in the General Decimal Arithmetic Specification and is the basis
 * for the opMul function for the Decimal struct.
 */
public Decimal multiply(
		const Decimal op1, const Decimal op2, const bool rounded = true) {

	Decimal product;
	// if invalid, return NaN
	if (isInvalidMultiplication(op1, op2, product)) {
		return product;
	}
    // if either operand is infinite, return infinity
	if (op1.isInfinite || op2.isInfinite) {
		product = Decimal.infinity;
		product.sign = op1.sign ^ op2.sign;
		return product;
	}
	// product is finite
	product.clear();
	product.mant = cast(BigInt)op1.mant * cast(BigInt)op2.mant;
	product.expo = op1.expo + op2.expo;
	product.sign = op1.sign ^ op2.sign;
	product.digits = numDigits(product.mant);
	if (rounded) {
		round(product);
	}
	return product;
}

// READY: fma
/**
 * Multiplies two numbers and adds a third number to the result.
 * The result of the multiplication is not rounded prior to the addition.
 *
 * This function corresponds to the "fused-multiply-add" function
 * in the General Decimal Arithmetic Specification.
 */
public Decimal fma(
		const Decimal op1, const Decimal op2, const Decimal op3) {

	Decimal product = multiply(op1, op2, false);
	return add(product, op3);
}

// READY: divide
/**
 * Divides one number by another and returns the quotient.
 * Division by zero sets a flag and returns Infinity.
 *
 * This function corresponds to the "divide" function
 * in the General Decimal Arithmetic Specification and is the basis
 * for the opDiv function for the Decimal struct.
 */
public Decimal divide(
		const Decimal op1, const Decimal op2, bool rounded = true) {

	Decimal quotient;
	// check for NaN and divide by zero
	if (isInvalidDivision(op1, op2, quotient)) {
		return quotient;
	}
	// if op1 is zero, quotient is zero
	if (isZeroDividend(op1, op2, quotient)) {
		return quotient;
	}

	quotient.clear();
	// TODO: are two guard digits necessary? sufficient?
	context.precision += 2;
	Decimal dividend = op1.dup;
	Decimal divisor  = op2.dup;
	int diff = dividend.expo - divisor.expo;
	if (diff > 0) {
		decShl(dividend.mant, diff);
		dividend.expo -= diff;
		dividend.digits += diff;
	}
	int shift = 2 + context.precision + divisor.digits - dividend.digits;
	if (shift > 0) {
		decShl(dividend.mant, shift);
		dividend.expo -= shift;
		dividend.digits += diff;
	}
	quotient.mant = dividend.mant / divisor.mant;
	quotient.expo = dividend.expo - divisor.expo;
	quotient.sign = dividend.sign ^ divisor.sign;
	quotient.digits = numDigits(quotient.mant);
	context.precision -= 2;
	if (rounded) {
		round(quotient);
		if (!context.getFlag(INEXACT)) {
			quotient = reduceToIdeal(quotient, diff);
    	}
	}
	return quotient;
}

// UNREADY: divideInteger. Error if integer value > precision digits. Duplicates code with divide?
/**
 * Divides one number by another and returns the integer portion of the quotient.
 * Division by zero sets a flag and returns Infinity.
 *
 * This function corresponds to the "divide-integer" function
 * in the General Decimal Arithmetic Specification.
 */
public Decimal divideInteger(const Decimal op1, const Decimal op2) {

	Decimal quotient;
	if (isInvalidDivision(op1, op2, quotient)) {
		return quotient;
	}
	if (isZeroDividend(op1, op2, quotient)) {
		return quotient;
	}

	quotient.clear();
	Decimal divisor = op1.dup;
	Decimal dividend = op2.dup;
	// align operands
	int diff = dividend.expo - divisor.expo;
	if (diff < 0) {
		decShl(divisor.mant, -diff);
	}
	if (diff > 0) {
		decShl(dividend.mant, diff);
	}
	quotient.mant = divisor.mant / dividend.mant;
	quotient.expo = 0;
	quotient.sign = dividend.sign ^ divisor.sign;
	quotient.digits = numDigits(quotient.mant);
	if (quotient.mant == 0) quotient.sval = Decimal.SV.ZERO;
	return quotient;
}

// UNREADY: remainder. Unit tests. Logic?
/**
 * Divides one number by another and returns the fractional remainder.
 * Division by zero sets a flag and returns Infinity.
 * The sign of the remainder is the same as that of the first operand.
 *
 * This function corresponds to the "remainder" function
 * in the General Decimal Arithmetic Specification.
 */
public Decimal remainder(const Decimal op1, const Decimal op2) {
	Decimal quotient;
	if (isInvalidDivision(op1, op2, quotient)) {
		return quotient;
	}
	if (isZeroDividend(op1, op2, quotient)) {
		return quotient;
	}
	quotient = divideInteger(op1, op2);
	Decimal remainder = op1 - multiply(op2, quotient, false);
	return remainder;
}

// UNREADY: remainderNear. Unit tests. Logic?
/**
 * Divides one number by another and returns the fractional remainder.
 * Division by zero sets a flag and returns Infinity.
 * The sign of the remainder is the same as that of the first operand.
 *
 * This function corresponds to the "remainder" function
 * in the General Decimal Arithmetic Specification.
 */
public Decimal remainderNear(const Decimal dividend, const Decimal divisor) {
	Decimal quotient;
	if (isInvalidDivision(dividend, divisor, quotient)) {
		return quotient;
	}
	if (isZeroDividend(dividend, divisor, quotient)) {
		return quotient;
	}
	quotient = divideInteger(dividend, divisor);
	Decimal remainder = dividend - multiply(divisor, quotient, false);
	return remainder;
}

//--------------------------------
// rounding routines
//--------------------------------

// UNREADY: roundToIntegralExact. Description. Name. Order.
// could set flags and then pop the context??
public Decimal roundToIntegralExact(const Decimal num){
	if (num.isSignaling) return flagInvalid();
	if (num.isSpecial) return num.dup;
	if (num.expo >= 0) return num.dup;
	pushPrecision();
	context.precision = num.digits;
	const Decimal ONE = Decimal(1);
	Decimal result = quantize(num, ONE);
	popPrecision;
	return result;
}

// UNREADY: roundToIntegralValue. Description. Name. Order. Logic.
public Decimal roundToIntegralValue(const Decimal num){
	// this operation shouldn't affect the inexact or rounded flags
	// so we'll save them in case they were already set.
	bool inexact = context.getFlag(INEXACT);
	bool rounded = context.getFlag(ROUNDED);
	Decimal result = roundToIntegralExact(num);
	context.setFlag(INEXACT, inexact);
	context.setFlag(ROUNDED, rounded);
	return result;
}

// UNREADY: round. Description. Private or public?
public void round(ref Decimal num) {

	if (!num.isFinite) return;

	context.clearFlags();
	// check for subnormal
	bool subnormal = false;
	if (num.isSubnormal()) {
		context.setFlag(SUBNORMAL);
		subnormal = true;
	}

	// check for overflow
	if (incrementOverflowed(num)) {
		context.setFlag(OVERFLOW);
		switch (context.mode) {
			case Rounding.HALF_UP:
			case Rounding.HALF_EVEN:
			case Rounding.HALF_DOWN:
			case Rounding.UP:
				bool sign = num.sign;
				num = Decimal.POS_INF;
				num.sign = sign;
				break;
			case Rounding.DOWN:
				bool sign = num.sign;
				num = Decimal.max;
				num.sign = sign;
				break;
			case Rounding.CEILING:
				if (num.sign) {
					num = Decimal.max;
					num.sign = true;
				}
				else {
					num = Decimal.POS_INF;
				}
				break;
			case Rounding.FLOOR:
				if (num.sign) {
					num = Decimal.NEG_INF;
				} else {
					num = Decimal.max;
				}
				break;
		}
		context.setFlag(INEXACT);
		context.setFlag(ROUNDED);
		return;
	}
	roundByMode(num);
	// check for underflow
	if (num.isSubnormal /*&& num.isInexact*/) {
		context.setFlag(SUBNORMAL);
		int diff = context.eTiny - num.adjustedExponent;
		if (diff > num.digits) {
			num.mant = 0;
			num.expo = context.eTiny;
		} else if (diff > 0) {
			// TODO: do something about this
			writeln("We got a tiny one!");
		}
	}
	// check for zero
	if (num.sval == Decimal.SV.CLEAR && num.mant == BigInt(0)) {
		num.sval = Decimal.SV.ZERO;
		// subnormal rounding to zero == clamped
		// Spec. p. 51
		if (subnormal) {
			context.setFlag(CLAMPED);
		}
		return;
	}
} // end round()

//--------------------------------
// private rounding routines
//--------------------------------

// UNREADY: shorten. Order. Unit tests.
/**
 * Clips the coefficient of the number to the specified precision.
 * Returns the (unsigned) remainder for adjustments based on rounding mode.
 * Sets the ROUNDED and INEXACT flags.
 */
private Decimal shorten(ref Decimal num) {
	Decimal remainder = Decimal.ZERO.dup;
	int diff = num.digits - context.precision;
	if (diff <= 0) {
		return remainder;
	}
	context.setFlag(ROUNDED);

	// the context can be zero when...??
	if (context.precision == 0) {
		num = num.sign ? Decimal.NEG_ZERO : Decimal.ZERO;
	} else {
		BigInt divisor = pow10(diff);
		BigInt dividend = num.mant;
		BigInt quotient = dividend/divisor;
		BigInt modulo = dividend - quotient*divisor;
		if (modulo != BigInt(0)) {
			remainder.digits = diff;
			remainder.expo = num.expo;
			remainder.mant = modulo;
			remainder.sval = Decimal.SV.CLEAR;
		}
		num.mant = quotient;
		num.digits = context.precision;
		num.expo += diff;
	}
	if (remainder != Decimal.ZERO) {
		context.setFlag(INEXACT);
	}

	return remainder;
}

// UNREADY: increment. Unit tests. Order.
// TODO: unittest this
/**
 * Increments the coefficient by 1. If this causes an overflow, divides by 10.
 */
private void increment(ref Decimal num) {
	num.mant += 1;
	// check if the num was all nines --
	// did the coefficient roll over to 1000...?
	Decimal test1 = Decimal(1, num.digits + num.expo);
	Decimal test2 = num;
	test2.digits++;
	int result = compare(test1, test2, false);
	if (result == 0) {
		num.expo++;
		num.digits++;
		setDigits(num);
	}
}

private bool incrementOverflowed(const Decimal num) {
	return num.adjustedExponent > context.eMax;
}

// UNREADY: roundByMode. Description. Order.
private void roundByMode(ref Decimal num) {
	Decimal remainder = shorten(num);

	// if the rounded flag is not set by the shorten operation, return
	if (!context.getFlag(ROUNDED)) {
		return;
	}
	// if the remainder is zero, return
	if (!context.getFlag(INEXACT)) {
		return;
	}

	switch (context.mode) {
		case Rounding.DOWN:
			return;
		case Rounding.HALF_UP:
			if (firstDigit(remainder.mant) >= 5) {
				increment(num);
			}
			return;
		case Rounding.HALF_EVEN:
			Decimal five = Decimal(5, remainder.digits + remainder.expo - 1);
			int result = compare(remainder, five, false);
			if (result > 0) {
				increment(num);
				return;
			}
			if (result < 0) {
				return;
			}
			// remainder == 5
			// if last digit is odd...
			if (lastDigit(num.mant) % 2) {
				increment(num);
			}
			return;
		case Rounding.CEILING:
			if (!num.sign && remainder != Decimal.ZERO) {
				increment(num);
			}
			return;
		case Rounding.FLOOR:
			if (num.sign && remainder != Decimal.ZERO) {
				increment(num);
			}
			return;
		case Rounding.HALF_DOWN:
			if (firstDigit(remainder.mant) > 5) {
				increment(num);
			}
			return;
		case Rounding.UP:
			if (remainder != Decimal.ZERO) {
				increment(num);
			}
			return;
	}	// end switch(mode)
} // end roundByMode()

// UNREADY: setDigits. Description. Ordering.
/**
 * Sets the number of digits to the current precision.
 */
package void setDigits(ref Decimal num) {
	int diff = num.digits - context.precision;
	if (diff > 0) {
		round(num);
	}
	else if (diff < 0) {
		num.mant = decShl(num.mant, -diff);
		num.expo += diff;
	}
	num.digits = context.precision;
}

// UNREADY: reduceToIdeal. Description. Flags.
/**
 * Reduces operand to simplest form. All trailing zeros are removed.
 * Reduces operand to specified exponent.
 */
 // TODO: has non-standard flag setting
private Decimal reduceToIdeal(const Decimal num, int ideal) {
	Decimal result;
	if (invalidOperand(num, result)) {
		return result;
	}
	result = num;
	if (!result.isFinite()) {
		return result;
	}
	BigInt temp = result.mant % 10;
	while (result.mant != 0 && temp == 0 && result.expo < ideal) {
		result.expo++;
		result.mant = result.mant / 10;
		temp = result.mant % 10;
	}
	if (result.mant == 0) {
		result.sval = Decimal.SV.ZERO;
		result.expo = 0;
	}
	result.digits = numDigits(result.mant);
	return result;
}

// UNREADY: flagInvalid. Unit Tests.
/**
 * Sets the invalid-operation flag and
 * returns a quiet NaN.
 */
private Decimal flagInvalid(ulong payload = 0) {
	context.setFlag(INVALID_OPERATION);
	Decimal result = Decimal.NaN.dup;
	if (payload != 0) {
		result.setNaNPayload(payload);
	}
	return result;
}

// UNREADY: alignOps. Unit tests. Todo.
// TODO: can this be used in division as well as addition?
/**
 * Aligns the two operands by raising the smaller exponent
 * to the value of the larger exponent, and adjusting the
 * coefficient so the value remains the same.
 */
private void alignOps(ref Decimal op1, ref Decimal op2) {
	int diff = op1.expo - op2.expo;
	if (diff > 0) {
		op1.mant = decShl(op1.mant, diff);
		op1.expo = op2.expo;
	}
	else if (diff < 0) {
		op2.mant = decShl(op2.mant, -diff);
		op2.expo = op1.expo;
	}
}

// UNREADY: isInvalidBinaryOp. Unit Tests. Payload.
/*
 * "The result of any arithmetic operation which has an operand
 * which is a NaN (a quiet NaN or a signaling NaN) is [s,qNaN]
 * or [s,qNaN,d]. The sign and any diagnostic information is copied
 * from the first operand which is a signaling NaN, or if neither is
 * signaling then from the first operand which is a NaN."
 * -- General Decimal Arithmetic Specification, p. 24
 */
private bool isInvalidBinaryOp(const Decimal op1, const Decimal op2,
		ref Decimal result) {
	// if either operand is a signaling NaN...
	if (op1.isSignaling || op2.isSignaling) {
		// flag the invalid operation
		context.setFlag(INVALID_OPERATION);
		// set the result to the first sNaN operand
		result = op1.isSignaling ? op1 : op2;
		// retain sign and payload; convert to qNaN
		result.sval = Decimal.SV.QNAN;
		return true;
	}
	// ...else if either operand is a quiet NaN...
	if (op1.isQuiet || op2.isQuiet) {
		// flag the invalid operation
		context.setFlag(INVALID_OPERATION);
		// set the result to the first qNaN operand
		result = op1.isQuiet ? op1 : op2;
		return true;
	}
	// ...otherwise, no flags are set and result is unchanged
	return false;
}

// UNREADY: isInvalidUnary. Unit Tests. Payload.
/*
 * "The result of any arithmetic operation which has an operand
 * which is a NaN (a quiet NaN or a signaling NaN) is [s,qNaN]
 * or [s,qNaN,d]. The sign and any diagnostic information is copied
 * from the first operand which is a signaling NaN, or if neither is
 * signaling then from the first operand which is a NaN."
 * -- General Decimal Arithmetic Specification, p. 24
 */
private bool invalidOperand(const Decimal op1, ref Decimal result) {
	// if the operand is a signaling NaN...
	if (op1.isSignaling) {
		// flag the invalid operation
		context.setFlag(INVALID_OPERATION);
		// set the result to the sNaN operand
		result = op1;
		// retain sign and payload; convert to qNaN
		result.sval = Decimal.SV.QNAN;
		return true;
	}
	// ...else if the operand is a quiet NaN...
	if (op1.isQuiet) {
		// flag the invalid operation
		context.setFlag(INVALID_OPERATION);
		// set the result to the qNaN operand
		result = op1;
		return true;
	}
	// ...otherwise, no flags are set and result is unchanged
	return false;
}

// UNREADY: isInvalidAddition. Description.
/*
 *	Checks for NaN operands and +infinity added to -infinity.
 *	If found, sets flags, sets the sum to NaN and returns true.
 *
 *	-- General Decimal Arithmetic Specification, p. 52, "Invalid operation"
 */
private bool isInvalidAddition(Decimal op1, Decimal op2, ref Decimal result) {
	if (isInvalidBinaryOp(op1, op2, result)) {
		return true;
	}
	// if both operands are infinite
	if (op1.isInfinite && op2.isInfinite) {
		// (+inf) + (-inf) => invalid operation
		if (op1.sign != op2.sign) {
			result = flagInvalid();
			return true;
		}
	}
	return false;
}

// UNREADY: isInvalidMultiplication. Flags. Unit Tests.
/*
 *	Checks for NaN operands and Infinity * Zero.
 *	If found, sets flags, sets the product to NaN and returns true.
 *
 *	-- General Decimal Arithmetic Specification, p. 52, "Invalid operation"
 */
private bool isInvalidMultiplication(
		const Decimal op1, const Decimal op2, ref Decimal result) {
	if (isInvalidBinaryOp(op1, op2, result)) {
		return true;
	}
	if (op1.isZero && op2.isInfinite || op1.isInfinite && op2.isZero) {
		result = Decimal.NaN;
		return true;
	}
	return false;
}


// UNREADY: isInvalidDivision. Unit Tests.
/*
 *	Checks for NaN operands and division by zero.
 *	If found, sets flags, sets the quotient to NaN or Infinity respectively
 *	and returns true.
 *
 * -- General Decimal Arithmetic Specification, p. 52, "Invalid operation"
 */
private bool isInvalidDivision(
	const Decimal dividend, const Decimal divisor, ref Decimal quotient) {
	if (isInvalidBinaryOp(dividend, divisor, quotient)) {
		return true;
	}
	if (divisor.isZero()) {
		if (dividend.isZero()) {
			quotient = flagInvalid();
		}
		else {
			context.setFlag(DIVISION_BY_ZERO);
			quotient.sval = Decimal.SV.INF;
			quotient.mant = BigInt(0);
			quotient.sign = dividend.sign ^ divisor.sign;
		}
		return true;
	}
	return false;
}

// UNREADY: isZeroDividend. Unit tests.
/**
 * Checks for a zero dividend. If found, sets the quotient to zero.
 */
private bool isZeroDividend(const Decimal dividend, const Decimal divisor,
		Decimal quotient) {
	if (dividend.isZero()) {
		quotient.sval = Decimal.SV.ZERO;
		quotient.mant = BigInt(0);
		quotient.expo = 0;
		quotient.digits = dividend.digits; // TODO: ??? should be 1???
		quotient.sign = dividend.sign;
		return true;
	}
	return false;
}

//--------------------------------

